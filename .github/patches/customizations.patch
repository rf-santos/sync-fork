diff --git a/.github/scripts/poll_workflow.py b/.github/scripts/poll_workflow.py
index aeba05f..d555342 100644
--- a/.github/scripts/poll_workflow.py
+++ b/.github/scripts/poll_workflow.py
@@ -2,64 +2,62 @@
 import os
 import sys
 import time
-import requests
 from datetime import datetime, timedelta
+from github import Github
+from github.GithubException import GithubException
 
-def poll_workflow(workflow_name, tag_name, repo):
-    token = os.environ['GITHUB_TOKEN']
-    headers = {
-        'Accept': 'application/vnd.github+json',
-        'Authorization': f'Bearer {token}'
-    }
-    
-    # Initial delay
-    time.sleep(15)
-    
-    start_time = datetime.now()
-    max_duration = timedelta(minutes=5)
-    
-    while datetime.now() - start_time < max_duration:
-        url = f'https://api.github.com/repos/{repo}/actions/runs'
-        response = requests.get(url, headers=headers)
+def poll_workflow(workflow_name, repo):
+    try:
+        gh = Github(os.environ['GITHUB_TOKEN'])
+        repository = gh.get_repo(repo)
         
-        if response.status_code != 200:
-            print(f"API request failed: {response.status_code}")
-            print(response.text)
-            sys.exit(1)
-            
-        data = response.json()
+        # Initial delay to allow workflow to start
+        time.sleep(15)
         
-        # Find relevant workflow runs
-        runs = [
-            run for run in data['workflow_runs']
-            if run['name'] == workflow_name 
-            and run['event'] == 'repository_dispatch'
-        ]
+        start_time = datetime.now()
+        max_duration = timedelta(minutes=5)
         
-        if not runs:
-            print("No matching workflow runs found. Waiting...")
+        while datetime.now() - start_time < max_duration:
+            runs = repository.get_workflow_runs(
+                event='repository_dispatch'
+            )
+            
+            matching_runs = [
+                run for run in runs
+                if run.name == workflow_name
+            ]
+            
+            if not matching_runs:
+                print("No matching workflow runs found. Waiting...")
+                time.sleep(10)
+                continue
+                
+            latest_run = matching_runs[0]
+            print(f"Latest run - Status: {latest_run.status}, Conclusion: {latest_run.conclusion}")
+            
+            if latest_run.status == 'completed':
+                if latest_run.conclusion == 'success':
+                    print("Workflow completed successfully")
+                    return 0
+                elif latest_run.conclusion:
+                    print(f"Workflow failed with conclusion: {latest_run.conclusion}")
+                    return 1
+                    
             time.sleep(10)
-            continue
             
-        latest_run = runs[0]
-        print(f"Latest run - Status: {latest_run['status']}, Conclusion: {latest_run['conclusion']}")
+        print("Timeout reached while waiting for workflow completion")
+        return 1
         
-        if latest_run['status'] == 'completed':
-            if latest_run['conclusion'] == 'success':
-                print("Workflow completed successfully")
-                sys.exit(0)
-            elif latest_run['conclusion']:
-                print(f"Workflow failed with conclusion: {latest_run['conclusion']}")
-                sys.exit(1)
-                
-        time.sleep(10)
-    
-    print("Timeout reached while waiting for workflow completion")
-    sys.exit(1)
+    except GithubException as e:
+        print(f"GitHub API error: {e}")
+        return 1
+    except Exception as e:
+        print(f"Unexpected error: {e}")
+        return 1
 
 if __name__ == '__main__':
-    if len(sys.argv) != 4:
-        print("Usage: poll_workflow.py WORKFLOW_NAME TAG_NAME REPO")
+    if len(sys.argv) != 3:
+        print("Usage: poll_workflow.py WORKFLOW_NAME REPO")
         sys.exit(1)
         
-    poll_workflow(sys.argv[1], sys.argv[2], sys.argv[3])
\ No newline at end of file
+    sys.exit(poll_workflow(sys.argv[1], sys.argv[2]))
\ No newline at end of file
diff --git a/.github/workflows/test_sync-fork.yml b/.github/workflows/test_sync-fork.yml
index f813458..22cac3c 100644
--- a/.github/workflows/test_sync-fork.yml
+++ b/.github/workflows/test_sync-fork.yml
@@ -51,7 +51,9 @@ jobs:
         id: poll_status
         env:
           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
-        run: python .github/scripts/poll_workflow.py "${{ env.WORKFLOW_NAME }}" "${{ env.TAG_NAME }}" "${{ github.repository }}"
+        run: |
+          pip install PyGithub
+          python .github/scripts/poll_workflow.py "${{ env.WORKFLOW_NAME }}" "${{ github.repository }}"
 
       - name: Verify main workflow success
         if: env.RUN_CONCLUSION != 'success'
@@ -60,17 +62,18 @@ jobs:
           exit 1
 
       - name: Cleanup tags and branches
+        if: always()
         run: |
           # Reset test patch file
-          echo "No patch applied" > .github/test/repos/upstream/test-patch.md
-          git add .github/test/repos/upstream/test-patch.md
-          git config --global user.name 'GitHub Actions'
-          git config --global user.email 'actions@github.com'
-          git commit -m "test: reset test patch file"
-          git push origin main
+          echo "No patch applied" > .github/test/repos/upstream/test-patch.md || true
+          git add .github/test/repos/upstream/test-patch.md || true
+          git config --global user.name 'GitHub Actions' || true
+          git config --global user.email 'actions@github.com' || true
+          git commit -m "test: reset test patch file" || true
+          git push origin main || true
       
           # Cleanup tags and branches
           TAG_NAME="${{ env.TAG_NAME }}"
-          git push origin :refs/tags/$TAG_NAME
+          git push origin :refs/tags/$TAG_NAME || true
           git branch -D sync-$TAG_NAME || true
           git push origin --delete sync-$TAG_NAME || true
\ No newline at end of file
