name: Sync Fork with Upstream Releases

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:
  repository_dispatch:
    types: [test-sync]

jobs:
  sync-fork:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout fork
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main

      - name: Configure Git
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'

      - name: Set Upstream Repo URL
        run: echo "UPSTREAM_REPO_URL=${{ github.event.client_payload.upstream_url || vars.UPSTREAM_REPO_URL }}" >> $GITHUB_ENV

      - name: Add upstream remote
        run: |
          git remote add upstream ${{ env.UPSTREAM_REPO_URL }}
          git fetch upstream --tags

      - name: Get latest and previous tags
        id: get_tags
        run: |
          # Get all tags from upstream sorted by creation date (newest first)
          TAGS=($(git ls-remote --tags --refs upstream | awk -F/ '{print $3}' | sort -V -r))
          
          # Get latest and previous tags
          LATEST_TAG="${TAGS[0]}"
          PREVIOUS_TAG="${TAGS[1]}"
          
          # Output tags for debugging
          echo "Latest tag: ${LATEST_TAG}"
          echo "Previous tag: ${PREVIOUS_TAG}"
          
          # Set environment variables
          echo "LATEST_TAG=${LATEST_TAG}" >> $GITHUB_ENV
          echo "PREVIOUS_TAG=${PREVIOUS_TAG}" >> $GITHUB_ENV

      - name: Create or update customizations.patch
        run: |
          # Checkout the previous upstream release to a temporary branch
          git checkout ${PREVIOUS_TAG} -b temp-branch
      
          # Diff the temporary branch with main to create patch
          git diff temp-branch..main > .github/patches/customizations.patch
      
          # Cleanup
          git checkout main
          git branch -D temp-branch

      - name: Check if release exists locally
        id: check_release
        run: |
          if git show-ref --tags --quiet --verify -- "refs/tags/${{ steps.latest_release.outputs.LATEST_TAG }}"; then
            echo "EXISTS=true" >> $GITHUB_OUTPUT
          else
            echo "EXISTS=false" >> $GITHUB_OUTPUT
          fi

      - name: Attempt merge
        id: merge_attempt
        if: steps.check_release.outputs.EXISTS == 'false'
        env:
          UPSTREAM_REPO_URL: ${{ env.UPSTREAM_REPO_URL }}
          LATEST_TAG: ${{ env.LATEST_TAG }}
          PREVIOUS_TAG: ${{ env.PREVIOUS_TAG }}
        run: |
          BRANCH_NAME="sync-${LATEST_TAG}"
          echo "BRANCH_NAME=${BRANCH_NAME}" >> $GITHUB_ENV
          git checkout -b $BRANCH_NAME
          if git merge ${LATEST_TAG} --no-edit; then
            echo "MERGE_STATUS=clean" >> $GITHUB_OUTPUT
          else
            git merge --abort
            echo "MERGE_STATUS=conflicts" >> $GITHUB_OUTPUT
          fi

      - name: Apply custom patches
        if: steps.check_release.outputs.EXISTS == 'false' && steps.merge_attempt.outputs.MERGE_STATUS == 'clean'
        run: |
          PATCH_FILE=".github/patches/customizations.patch"
          if [ "${{ github.event_name }}" = "repository_dispatch" ] && [ "${{ github.event.action }}" = "test-sync" ]; then
            PATCH_FILE=".github/patches/test-customizations.patch"
          fi

          if [ -f $PATCH_FILE ]; then
            if git apply --check $PATCH_FILE; then
              git apply $PATCH_FILE
              echo "PATCH_STATUS=success" >> $GITHUB_OUTPUT
            else
              echo "PATCH_STATUS=failed" >> $GITHUB_OUTPUT
            fi
          fi
        id: patch_apply

      - name: Create Pull Request
        if: steps.check_release.outputs.EXISTS == 'false' && steps.merge_attempt.outputs.MERGE_STATUS == 'clean'
        uses: peter-evans/create-pull-request@v5
        id: create_pr
        with:
          title: 'Sync: Upstream release ${{ env.LATEST_TAG }}'
          body: |
            This PR synchronizes our fork with upstream release ${{ env.LATEST_TAG }}.
            - Merge Status: ${{ steps.merge_attempt.outputs.MERGE_STATUS }}
            - Patch Status: ${{ steps.patch_apply.outputs.PATCH_STATUS }}
            This PR will be automatically merged if there are no conflicts.
          branch: ${{ env.BRANCH_NAME }}
          base: main
          labels: sync,automated

      - name: Auto-merge Pull Request
        if: |
          steps.create_pr.outputs.pull-request-operation == 'created' && 
          steps.merge_attempt.outputs.MERGE_STATUS == 'clean' && 
          steps.patch_apply.outputs.PATCH_STATUS == 'success'
        run: |
          gh pr merge ${{ steps.create_pr.outputs.pull-request-number }} --auto --merge
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Notify on Failure
        if: |
          failure() || 
          steps.merge_attempt.outputs.MERGE_STATUS == 'conflicts' || 
          steps.patch_apply.outputs.PATCH_STATUS == 'failed'
        uses: actions/github-script@v7
        with:
          script: |
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.name,
              title: '⚠️ Sync failed for release ${{ steps.latest_release.outputs.LATEST_TAG }}',
              body: `
                Synchronization with upstream release ${{ steps.latest_release.outputs.LATEST_TAG }} failed.
                - Merge Status: ${{ steps.merge_attempt.outputs.MERGE_STATUS }}
                - Patch Status: ${{ steps.patch_apply.outputs.PATCH_STATUS }}
                Manual intervention is required.
              `
            });